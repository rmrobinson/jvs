#pragma once

#include <unordered_map>

#include <openzwave/Notification.h>
#include <openzwave/Manager.h>
#include <openzwave/Options.h>

#include "util-cpp/concurrent_queue.hpp"
#include "devicemanager-cpp/device_manager.hpp"

#include "message.hpp"
#include "driver.hpp"

namespace jvs {
namespace openzwaved {

class Server {
public:
    Server();
    ~Server();

    void run(const std::vector<std::string>& devicePaths, const uint16_t port);

    void stop();

    /// @brief Interface for other threads to access the server state.
    /// To prevent threading issues, all requests must be made in the form of a Message,
    /// which will be interpreted and a threadsafe copy of the data will be returned.
    /// @param message The requested data. See struct Message above.
    void sendMessage(const Message& message);

private:
    /// @brief Callback handler registered to receive events generated by the OpenZWave API.
    /// This will be called on one of several OpenZWave managed threads.
    static void onZwaveNotification(OpenZWave::Notification const* n, void* c);

    /// @brief Class-specific handler for events generated by the OpenZWave API.
    /// This may be called from multiple threads, so it locks data structures it needs.
    void processZwaveNotification(const OpenZWave::Notification* n);

    void processCommandMessage(const Message& message);

    /// @brief We will have a thread-safe queue here which the main thread pops events off to process.
    /// The OnZwaveNotification handler will slightly deserialize the notification then push it onto the queue.
    /// The gRPC handlers will format the commands as appropriate then push it onto the queue.
    /// The main thread will take all received messages and pass them to the appropriate methods.
    ConcurrentQueue<Message> _messages;

    /// @brief The server will hold a reference to the device manager, which will expose the service to the network.
    DeviceManager _deviceManager;

    /// @brief The server will hold a pointer to the manager and multiplex all of the inbound and outbound communication.
    /// We will use this handle, instead of the static Manager::Get(), to possibly support multiple handles if ozw changes in the future.
    OpenZWave::Manager* _zwaveManager;

    /// @brief The server will hold a pointer to the options used to initialize the manager.
    /// We will use this handle, instead of the static Options::Get(), to possibley support multiple handles if ozw changes in the future.
    OpenZWave::Options* _options;

    /// @brief Used to exit the message processing queue.
    bool _done;

    /// @brief Upon detecting a new ZWave home ID, we will create a driver with that home ID and insert it into this map.
    /// All future updates will use this map to address the appropriate driver.
    std::unordered_map<uint32_t, std::shared_ptr<Driver> > _drivers;

    /// @brief Serializes access to the _drivers collection.
    mutable std::mutex _driversMutex;
    
};

}
}

