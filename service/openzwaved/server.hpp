#pragma once

#include <unordered_map>

#include <openzwave/Notification.h>
#include <openzwave/Manager.h>
#include <openzwave/Options.h>

#include "util-cpp/concurrent_queue.hpp"
#include "devicemanager-cpp/device_manager.hpp"

#include "driver.hpp"

namespace jvs {
namespace openzwaved {

class Server {
public:
    Server();
    ~Server();

    void run(const std::vector<std::string>& devicePaths, const uint16_t port);

    void stop();

private:
    /// @brief Callback handler registered to receive events generated by the OpenZWave API.
    /// This will be called on one of several OpenZWave managed threads.
    static void onZwaveNotification(OpenZWave::Notification const* n, void* c);

    /// @brief Class-specific handler for events generated by the OpenZWave API.
    /// This may be called from multiple threads, so it locks data structures it needs.
    void processZwaveNotification(const OpenZWave::Notification* n);

    /// @brief The server will hold a reference to the device manager, which will expose the service to the network.
    DeviceManager _deviceManager;

    /// @brief The server will hold a pointer to the manager and multiplex all of the inbound and outbound communication.
    /// We will use this handle, instead of the static Manager::Get(), to possibly support multiple handles if ozw changes in the future.
    OpenZWave::Manager* _zwaveManager;

    /// @brief The server will hold a pointer to the options used to initialize the manager.
    /// We will use this handle, instead of the static Options::Get(), to possibley support multiple handles if ozw changes in the future.
    OpenZWave::Options* _options;

    /// @brief Used to exit the command processing queue.
    bool _done;

    /// @brief Upon detecting a new ZWave home ID, we will create a driver with that home ID and insert it into this map.
    /// All future updates will use this map to address the appropriate driver.
    std::unordered_map<uint32_t, std::shared_ptr<Driver> > _drivers;

    /// @brief Serializes access to the _drivers collection.
    mutable std::mutex _driversMutex;
    
};

}
}

